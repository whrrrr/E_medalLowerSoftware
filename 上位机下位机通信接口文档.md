# 上位机下位机通信接口文档

## 1. 概述

本文档定义了Android上位机应用与HC32L110微控制器下位机之间的通信协议，用于传输400x300像素的黑白和红白图像数据到电子墨水屏显示设备。

### 1.1 系统架构
- **上位机**: Android应用 (通过蓝牙SPP协议)
- **下位机**: HC32L110微控制器 + E104蓝牙模块
- **显示设备**: 400x300像素三色电子墨水屏
- **存储**: W25Q32 Flash存储器

### 1.2 通信方式
- **物理层**: 蓝牙SPP (Serial Port Profile)
- **数据层**: 自定义二进制协议
- **波特率**: 115200 bps
- **数据位**: 8位
- **停止位**: 1位
- **校验位**: 无

## 2. 协议常量定义

### 2.1 魔法数字
```java
public static final int PROTOCOL_MAGIC_HOST = 0xA5A5;  // 上位机发送魔法数
public static final int PROTOCOL_MAGIC_MCU = 0x5A5A;   // 下位机回复魔法数
public static final long PROTOCOL_END_HOST = 0xA5A5AFAFL;  // 上位机结束魔法数
public static final long PROTOCOL_END_MCU = 0x5A5A5F5FL;   // 下位机结束魔法数
```

### 2.2 命令类型
```java
public static final byte CMD_IMAGE_TRANSFER = (byte)0xC0;  // 图像传输开始命令
public static final byte CMD_IMAGE_DATA = (byte)0xD0;      // 图像数据传输命令
public static final byte CMD_TRANSFER_END = (byte)0xC1;    // 传输结束命令
```

### 2.3 颜色类型
```java
public static final byte COLOR_TYPE_BW = 0x00;   // 黑白图像
public static final byte COLOR_TYPE_RED = 0x10;  // 红白图像
```

### 2.4 状态码
```java
// MCU回复状态
public static final byte MCU_STATUS_OK = 0x01;     // 确认无误
public static final byte MCU_STATUS_BUSY = 0x02;   // 忙碌
public static final byte MCU_STATUS_ERROR = (byte)0xFF;  // 错误

// 数据帧回复状态
public static final byte DATA_STATUS_OK = 0x00;           // 无错误
public static final byte DATA_STATUS_CRC_ERROR = 0x10;    // CRC错误，全部重传
public static final byte DATA_STATUS_FRAME_MISSING = 0x20; // 丢失帧，低4位表示帧号
public static final byte DATA_STATUS_TIMEOUT = 0x30;      // 超时中断
```

### 2.5 图像参数
```java
public static final int IMAGE_WIDTH = 400;
public static final int IMAGE_HEIGHT = 300;
public static final int IMAGE_SIZE = (IMAGE_WIDTH * IMAGE_HEIGHT) / 8;  // 15000字节
public static final int IMAGE_PAGES_PER_COLOR = 61;  // 每种颜色需要61页
public static final int IMAGE_DATA_PER_PAGE = 248;   // 每页248字节数据
public static final int IMAGE_LAST_PAGE_DATA_SIZE = 120;  // 最后一页120字节
public static final int FRAME_DATA_SIZE = 54;        // 前4帧每帧54字节
public static final int FRAME_LAST_DATA_SIZE = 32;   // 第5帧32字节
public static final int FRAMES_PER_PAGE = 5;         // 每页5帧
```

## 3. 数据帧格式定义

### 3.1 首帧格式 (8字节)

**上位机发送首帧**:
```
+--------+--------+--------+--------+--------+--------+--------+--------+
| Magic  | Magic  |Command |SlotCol | End Magic (4字节)                |
| 0xA5   | 0xA5   | 0xC0   |S+C     | 0xA5A5AFAF                       |
+--------+--------+--------+--------+--------+--------+--------+--------+
字节:  0      1      2      3      4      5      6      7
```

- **Magic**: 0xA5A5 (小端序)
- **Command**: 0xC0 (图像传输命令)
- **SlotColor**: 低4位为槽位(0-15)，高4位为颜色类型(0=黑白, 1=红白)
- **End Magic**: 0xA5A5AFAF (小端序)

**下位机回复首帧** (10字节):
```
+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
| Magic  | Magic  |Command |SlotCol |Status  |Reserve | End Magic (4字节)              |
| 0x5A   | 0x5A   | 0xC0   |S+C     |Status  | 0x00   | 0x5A5A5F5F                     |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
字节:  0      1      2      3      4      5      6      7      8      9
```

### 3.2 数据帧格式 (64字节)

**上位机发送数据帧**:
```
+--------+--------+--------+--------+--------+--------+--------+--------+
| Magic  | Magic  |Command |SlotCol |PageSeq |FrameSeq| Data (54字节)   |
| 0xA5   | 0xA5   | 0xD0   |S+C     |1-61    |1-5     | ...             |
+--------+--------+--------+--------+--------+--------+--------+--------+
|                    Data继续 (46字节)                    | End Magic     |
|                    ...                                  | 0xA5A5AFAF    |
+--------+--------+--------+--------+--------+--------+--------+--------+
字节:  0      1      2      3      4      5    6-59     60-63
```

- **PageSeq**: 页序列号 (1-61)
- **FrameSeq**: 帧序列号 (1-5)
- **Data**: 数据内容
  - 前4帧: 54字节图像数据
  - 第5帧: 32字节图像数据 + 4字节CRC32校验

**下位机回复数据帧** (6字节):
```
+--------+--------+--------+--------+--------+--------+
| Magic  | Magic  |Command |SlotCol |PageSeq |Status  |
| 0x5A   | 0x5A   | 0xD0   |S+C     |1-61    |Status  |
+--------+--------+--------+--------+--------+--------+
字节:  0      1      2      3      4      5
```

### 3.3 尾帧格式 (8字节)

**上位机发送尾帧**:
```
+--------+--------+--------+--------+--------+--------+--------+--------+
| Magic  | Magic  |Command |SlotCol | End Magic (4字节)                |
| 0xA5   | 0xA5   | 0xC1   |S+C     | 0xA5A5AFAF                       |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

**下位机回复尾帧** (8字节):
```
+--------+--------+--------+--------+--------+--------+--------+--------+
| Magic  | Magic  |Command |SlotCol | End Magic (4字节)                |
| 0x5A   | 0x5A   | 0xC1   |S+C     | 0x5A5A5F5F                       |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

## 4. 传输流程

### 4.1 完整传输流程

```
上位机                           下位机
  |                                |
  |-- 1. 发送黑白首帧 ------------->|
  |<-- 1. 回复首帧确认 -------------|
  |                                |
  |-- 2. 发送黑白数据页1-61 ------->|
  |<-- 2. 逐页确认 -----------------|
  |                                |
  |-- 3. 发送红白首帧 ------------->|
  |<-- 3. 回复首帧确认 -------------|
  |                                |
  |-- 4. 发送红白数据页1-61 ------->|
  |<-- 4. 逐页确认 -----------------|
  |                                |
  |-- 5. 发送尾帧 ----------------->|
  |<-- 5. 回复尾帧确认 -------------|
  |                                |
```

### 4.2 单页数据传输流程

每页数据分5帧传输:
1. **前4帧**: 每帧54字节数据
2. **第5帧**: 32字节数据 + 4字节CRC32校验

```
上位机                           下位机
  |                                |
  |-- 帧1 (54字节) ---------------->|
  |-- 帧2 (54字节) ---------------->|
  |-- 帧3 (54字节) ---------------->|
  |-- 帧4 (54字节) ---------------->|
  |-- 帧5 (32字节+CRC) ------------>|
  |<-- 页确认回复 ------------------|
```

## 5. Android实现示例

### 5.1 数据结构定义

```java
public class ImageProtocol {
    // 首帧结构
    public static class StartFrame {
        public short magic = PROTOCOL_MAGIC_HOST;
        public byte command = CMD_IMAGE_TRANSFER;
        public byte slotColor;  // 低4位槽位，高4位颜色
        public int endMagic = (int)PROTOCOL_END_HOST;
        
        public byte[] toBytes() {
            ByteBuffer buffer = ByteBuffer.allocate(8);
            buffer.order(ByteOrder.LITTLE_ENDIAN);
            buffer.putShort(magic);
            buffer.put(command);
            buffer.put(slotColor);
            buffer.putInt(endMagic);
            return buffer.array();
        }
    }
    
    // 数据帧结构
    public static class DataFrame {
        public short magic = PROTOCOL_MAGIC_HOST;
        public byte command = CMD_IMAGE_DATA;
        public byte slotColor;
        public byte pageSeq;
        public byte frameSeq;
        public byte[] data = new byte[54];
        public int endMagic = (int)PROTOCOL_END_HOST;
        
        public byte[] toBytes() {
            ByteBuffer buffer = ByteBuffer.allocate(64);
            buffer.order(ByteOrder.LITTLE_ENDIAN);
            buffer.putShort(magic);
            buffer.put(command);
            buffer.put(slotColor);
            buffer.put(pageSeq);
            buffer.put(frameSeq);
            buffer.put(data);
            buffer.putInt(endMagic);
            return buffer.array();
        }
    }
}
```

### 5.2 CRC32计算

```java
public class CRC32Calculator {
    private static final long CRC32_POLYNOMIAL = 0xEDB88320L;
    
    public static long calculateCRC32(byte[] data) {
        long crc = 0xFFFFFFFFL;
        
        for (byte b : data) {
            crc ^= (b & 0xFF);
            for (int i = 0; i < 8; i++) {
                if ((crc & 1) != 0) {
                    crc = (crc >>> 1) ^ CRC32_POLYNOMIAL;
                } else {
                    crc >>>= 1;
                }
            }
        }
        
        return (~crc) & 0xFFFFFFFFL;
    }
}
```

### 5.3 图像传输管理器

```java
public class ImageTransferManager {
    private BluetoothSocket socket;
    private InputStream inputStream;
    private OutputStream outputStream;
    private static final int MAX_RETRIES = 3;
    private static final int TIMEOUT_MS = 5000;
    
    public boolean sendImage(byte[] bwImageData, byte[] redImageData, int slot) {
        try {
            // 1. 发送黑白图像
            if (!sendImageColor(bwImageData, COLOR_TYPE_BW, slot)) {
                return false;
            }
            
            // 2. 发送红白图像
            if (!sendImageColor(redImageData, COLOR_TYPE_RED, slot)) {
                return false;
            }
            
            // 3. 发送尾帧
            return sendEndFrame(slot);
            
        } catch (Exception e) {
            Log.e("ImageTransfer", "传输失败", e);
            return false;
        }
    }
    
    private boolean sendImageColor(byte[] imageData, byte colorType, int slot) {
        // 发送首帧
        if (!sendStartFrame(slot, colorType)) {
            return false;
        }
        
        // 发送数据页
        for (int pageSeq = 1; pageSeq <= IMAGE_PAGES_PER_COLOR; pageSeq++) {
            if (!sendDataPage(imageData, pageSeq, slot, colorType)) {
                return false;
            }
        }
        
        return true;
    }
    
    private boolean sendDataPage(byte[] imageData, int pageSeq, int slot, byte colorType) {
        // 计算页数据
        int startPos = (pageSeq - 1) * IMAGE_DATA_PER_PAGE;
        int dataSize = (pageSeq == IMAGE_PAGES_PER_COLOR) ? 
                      IMAGE_LAST_PAGE_DATA_SIZE : IMAGE_DATA_PER_PAGE;
        
        byte[] pageData = new byte[IMAGE_DATA_PER_PAGE];
        System.arraycopy(imageData, startPos, pageData, 0, dataSize);
        
        // 计算CRC32
        long pageCRC = CRC32Calculator.calculateCRC32(
            Arrays.copyOf(pageData, dataSize));
        
        // 发送5帧数据
        for (int frameSeq = 1; frameSeq <= 5; frameSeq++) {
            if (!sendDataFrame(pageData, pageSeq, frameSeq, slot, colorType, pageCRC)) {
                return false;
            }
        }
        
        // 等待页确认
        return waitDataReply(pageSeq);
    }
}
```

## 6. 错误处理机制

### 6.1 重传机制
- **最大重试次数**: 3次
- **超时时间**: 5秒
- **重传触发条件**:
  - CRC校验错误
  - 帧丢失
  - 超时无响应
  - 下位机忙碌状态

### 6.2 错误码处理

```java
public enum TransferError {
    SUCCESS(0, "传输成功"),
    TIMEOUT(1, "通信超时"),
    CRC_ERROR(2, "CRC校验错误"),
    FRAME_MISSING(3, "数据帧丢失"),
    MCU_BUSY(4, "下位机忙碌"),
    MCU_ERROR(5, "下位机错误"),
    BLUETOOTH_ERROR(6, "蓝牙连接错误"),
    DATA_FORMAT_ERROR(7, "数据格式错误");
    
    private final int code;
    private final String message;
    
    TransferError(int code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

## 7. 性能优化建议

### 7.1 传输优化
- **分包传输**: 大图像分61页传输，避免内存溢出
- **CRC校验**: 每页独立校验，减少重传开销
- **流控制**: 逐页确认，确保数据完整性

### 7.2 用户体验优化
- **进度显示**: 实时显示传输进度 (页数/总页数)
- **状态反馈**: 清晰的错误信息和状态提示
- **取消功能**: 支持用户中途取消传输

### 7.3 连接管理
- **自动重连**: 蓝牙断开时自动尝试重连
- **连接检测**: 定期检测连接状态
- **资源释放**: 及时释放蓝牙资源

## 8. 调试和测试

### 8.1 调试信息
- 启用详细日志记录
- 记录每个数据包的发送和接收
- 监控CRC校验结果
- 统计重传次数和成功率

### 8.2 测试用例
- **正常传输**: 完整图像传输测试
- **网络中断**: 蓝牙断开重连测试
- **数据损坏**: CRC错误处理测试
- **边界条件**: 最大/最小图像尺寸测试

## 9. 常见问题解决

### 9.1 传输失败
- 检查蓝牙连接状态
- 验证图像数据格式
- 确认下位机状态
- 检查CRC计算是否正确

### 9.2 传输缓慢
- 优化数据包大小
- 减少重传次数
- 检查蓝牙信号强度
- 优化CRC计算算法

### 9.3 显示异常
- 验证图像数据完整性
- 检查颜色类型设置
- 确认槽位参数正确
- 验证图像尺寸匹配

---

**文档版本**: 1.0  
**最后更新**: 2024年  
**适用系统**: Android 5.0+ / HC32L110微控制器